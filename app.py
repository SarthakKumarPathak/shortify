# -*- coding: utf-8 -*-
"""app.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16NuJQGj7UsB5FsEh6IoPF8VjUNc-aDaI
"""

# Commented out IPython magic to ensure Python compatibility.
# %pip install streamlit moviepy yt-dlp

import streamlit as st
from moviepy.editor import VideoFileClip
from moviepy.video.fx.all import crop
import yt_dlp
import tempfile
import os
import re

def parse_time_ranges(text):
    ranges = []
    pattern = r"(\d{1,2}:\d{2})\s*-\s*(\d{1,2}:\d{2})"
    for match in re.findall(pattern, text):
        def to_sec(t): return int(t.split(":")[0])*60 + int(t.split(":")[1])
        ranges.append((to_sec(match[0]), to_sec(match[1])))
    return ranges

def download_youtube_video(url, output_path):
    ydl_opts = {
        'format': 'bv*[ext=mp4]+ba[ext=m4a]/b[ext=mp4]/best',
        'outtmpl': output_path,
        'quiet': True,
        'merge_output_format': 'mp4'
    }
    with yt_dlp.YoutubeDL(ydl_opts) as ydl:
        ydl.download([url])

st.title("üé¨ YouTube Shorts/Clip Generator")

video_url = st.text_input("Enter YouTube URL:")
orientation = st.radio("Select Orientation", ["original", "shorts (9:16)"])
time_range_text = st.text_area("Enter time ranges (mm:ss - mm:ss, one per line)", "00:10 - 00:25\n01:00 - 01:15")

if st.button("Generate Clips"):
    if not video_url or not time_range_text:
        st.warning("Please provide both a YouTube URL and time ranges.")
    else:
        with tempfile.TemporaryDirectory() as tmpdir:
            st.info("üì• Downloading video...")
            video_path = os.path.join(tmpdir, "input_video.mp4")

            try:
                download_youtube_video(video_url, video_path)
            except Exception as e:
                st.error(f"‚ùå Video download failed: {e}")
                st.stop()

            try:
                clip_ranges = parse_time_ranges(time_range_text)
                if not clip_ranges:
                    st.error("‚ö†Ô∏è Invalid time ranges.")
                    st.stop()

                video = VideoFileClip(video_path)
                w, h = video.size
                target_aspect = 9 / 16
                target_width = int(h * target_aspect)

                for i, (start, end) in enumerate(clip_ranges, 1):
                    clip = video.subclip(start, end)
                    if "shorts" in orientation:
                        x_center = w // 2
                        x1 = max(0, x_center - target_width // 2)
                        x2 = min(w, x_center + target_width // 2)
                        clip = crop(clip, x1=x1, x2=x2)

                    out_path = os.path.join(tmpdir, f"clip_{i}.mp4")
                    clip.write_videofile(out_path, codec="libx264", audio_codec="aac", verbose=False, logger=None)

                    with open(out_path, "rb") as f:
                        st.download_button(
                            label=f"üì• Download Clip {i}",
                            data=f,
                            file_name=f"clip_{i}.mp4",
                            mime="video/mp4"
                        )
                st.success("‚úÖ All clips generated!")

            except Exception as e:
                st.error(f"‚ö†Ô∏è Error: {e}")

# Trigger rebuild
